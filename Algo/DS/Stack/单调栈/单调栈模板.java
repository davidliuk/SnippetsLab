// 最常见的使用场景，找到向左或者向右第一个比这个元素大或者小的位置
// 一个元素在栈中就说明该元素的答案还没有被计算过
// 要计算元素的结果，就出栈
// 入栈前判断单调性是否存在，不存在就一直弹出直到存在
// 栈里面存下标（根据下标可以直接找到元素，反过来不行）
// 时空复杂度On
for i from 0 to (n - 1)
    while 栈不空 and 单调性不存在
        记录此时的答案 //一般是在弹之前，但也有特殊情况
        stack.pop()
    stack.push(i)

// 编程复杂度低，思维复杂度高（好写，不好想）